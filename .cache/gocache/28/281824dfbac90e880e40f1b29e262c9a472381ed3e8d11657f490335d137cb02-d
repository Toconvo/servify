//line /Users/cui/Workspaces/servify/internal/services/circuit_breaker.go:1:1
package services

import (
	"sync"
	"time"
)

// CircuitBreakerState 熔断器状态
type CircuitBreakerState int

const (
	StateClosedCB CircuitBreakerState = iota // 关闭状态（正常）
	StateOpenCB                              // 开启状态（熔断）
	StateHalfOpenCB                          // 半开状态（试探）
)

func (s CircuitBreakerState) String() string {goCover_649b36dcf066__41[0] = 5 ; goCover_649b36dcf066__41[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__41[2] = 41 ; goCover_649b36dcf066__41[3] = 1;
	switch s {
	case StateClosedCB:goCover_649b36dcf066__41[4] = 1;
		return "closed"
	case StateOpenCB:goCover_649b36dcf066__41[5] = 1;
		return "open"
	case StateHalfOpenCB:goCover_649b36dcf066__41[6] = 1;
		return "half-open"
	default:goCover_649b36dcf066__41[7] = 1;
		return "unknown"
	}
}

// CircuitBreakerConfig 熔断器配置
type CircuitBreakerConfig struct {
	MaxFailures     int           `yaml:"max_failures"`     // 最大失败次数
	ResetTimeout    time.Duration `yaml:"reset_timeout"`    // 重置超时时间
	HalfOpenMaxReqs int           `yaml:"half_open_max_reqs"` // 半开状态最大请求数
}

// DefaultCircuitBreakerConfig 默认熔断器配置
func DefaultCircuitBreakerConfig() *CircuitBreakerConfig {goCover_649b36dcf066__42[0] = 1 ; goCover_649b36dcf066__42[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__42[2] = 42 ; goCover_649b36dcf066__42[3] = 1;
	return &CircuitBreakerConfig{
		MaxFailures:     5,
		ResetTimeout:    60 * time.Second,
		HalfOpenMaxReqs: 3,
	}
}

// CircuitBreaker 熔断器实现
type CircuitBreaker struct {
	config       *CircuitBreakerConfig
	state        CircuitBreakerState
	failureCount int
	lastFailTime time.Time
	halfOpenReqs int
	mutex        sync.RWMutex
}

// NewCircuitBreaker 创建新的熔断器
func NewCircuitBreaker() *CircuitBreaker {goCover_649b36dcf066__43[0] = 1 ; goCover_649b36dcf066__43[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__43[2] = 43 ; goCover_649b36dcf066__43[3] = 1;
	return NewCircuitBreakerWithConfig(DefaultCircuitBreakerConfig())
}

// NewCircuitBreakerWithConfig 使用配置创建熔断器
func NewCircuitBreakerWithConfig(config *CircuitBreakerConfig) *CircuitBreaker {goCover_649b36dcf066__44[0] = 1 ; goCover_649b36dcf066__44[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__44[2] = 44 ; goCover_649b36dcf066__44[3] = 1;
	return &CircuitBreaker{
		config: config,
		state:  StateClosedCB,
	}
}

// Allow 检查是否允许请求通过
func (cb *CircuitBreaker) Allow() bool {goCover_649b36dcf066__45[0] = 9 ; goCover_649b36dcf066__45[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__45[2] = 45 ; goCover_649b36dcf066__45[3] = 1;
	cb.mutex.Lock()
	defer cb.mutex.Unlock()

	switch cb.state {
	case StateClosedCB:goCover_649b36dcf066__45[4] = 1;
		return true

	case StateOpenCB:goCover_649b36dcf066__45[5] = 1;
		// 检查是否可以转为半开状态
		if time.Since(cb.lastFailTime) > cb.config.ResetTimeout {goCover_649b36dcf066__45[10] = 1;
			cb.state = StateHalfOpenCB
			cb.halfOpenReqs = 0
			return true
		}
		goCover_649b36dcf066__45[6] = 1;return false

	case StateHalfOpenCB:goCover_649b36dcf066__45[7] = 1;
		// 半开状态下限制请求数量
		if cb.halfOpenReqs < cb.config.HalfOpenMaxReqs {goCover_649b36dcf066__45[11] = 1;
			cb.halfOpenReqs++
			return true
		}
		goCover_649b36dcf066__45[8] = 1;return false

	default:goCover_649b36dcf066__45[9] = 1;
		return false
	}
}

// OnSuccess 记录成功请求
func (cb *CircuitBreaker) OnSuccess() {goCover_649b36dcf066__46[0] = 3 ; goCover_649b36dcf066__46[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__46[2] = 46 ; goCover_649b36dcf066__46[3] = 1;
	cb.mutex.Lock()
	defer cb.mutex.Unlock()

	switch cb.state {
	case StateClosedCB:goCover_649b36dcf066__46[4] = 1;
		// 重置失败计数
		cb.failureCount = 0

	case StateHalfOpenCB:goCover_649b36dcf066__46[5] = 1;
		// 半开状态成功，转为关闭状态
		cb.state = StateClosedCB
		cb.failureCount = 0
		cb.halfOpenReqs = 0
	}
}

// OnFailure 记录失败请求
func (cb *CircuitBreaker) OnFailure() {goCover_649b36dcf066__47[0] = 4 ; goCover_649b36dcf066__47[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__47[2] = 47 ; goCover_649b36dcf066__47[3] = 1;
	cb.mutex.Lock()
	defer cb.mutex.Unlock()

	cb.failureCount++
	cb.lastFailTime = time.Now()

	switch cb.state {
	case StateClosedCB:goCover_649b36dcf066__47[4] = 1;
		// 检查是否达到失败阈值
		if cb.failureCount >= cb.config.MaxFailures {goCover_649b36dcf066__47[6] = 1;
			cb.state = StateOpenCB
		}

	case StateHalfOpenCB:goCover_649b36dcf066__47[5] = 1;
		// 半开状态失败，立即转为开启状态
		cb.state = StateOpenCB
		cb.halfOpenReqs = 0
	}
}

// State 获取当前状态
func (cb *CircuitBreaker) State() CircuitBreakerState {goCover_649b36dcf066__48[0] = 1 ; goCover_649b36dcf066__48[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__48[2] = 48 ; goCover_649b36dcf066__48[3] = 1;
	cb.mutex.RLock()
	defer cb.mutex.RUnlock()
	return cb.state
}

// FailureCount 获取失败计数
func (cb *CircuitBreaker) FailureCount() int {goCover_649b36dcf066__49[0] = 1 ; goCover_649b36dcf066__49[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__49[2] = 49 ; goCover_649b36dcf066__49[3] = 1;
	cb.mutex.RLock()
	defer cb.mutex.RUnlock()
	return cb.failureCount
}

// Reset 重置熔断器
func (cb *CircuitBreaker) Reset() {goCover_649b36dcf066__50[0] = 1 ; goCover_649b36dcf066__50[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__50[2] = 50 ; goCover_649b36dcf066__50[3] = 1;
	cb.mutex.Lock()
	defer cb.mutex.Unlock()

	cb.state = StateClosedCB
	cb.failureCount = 0
	cb.halfOpenReqs = 0
}

// Stats 获取熔断器统计信息
func (cb *CircuitBreaker) Stats() map[string]interface{} {goCover_649b36dcf066__51[0] = 1 ; goCover_649b36dcf066__51[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__51[2] = 51 ; goCover_649b36dcf066__51[3] = 1;
	cb.mutex.RLock()
	defer cb.mutex.RUnlock()

	return map[string]interface{}{
		"state":            cb.state.String(),
		"failure_count":    cb.failureCount,
		"last_fail_time":   cb.lastFailTime,
		"half_open_reqs":   cb.halfOpenReqs,
		"max_failures":     cb.config.MaxFailures,
		"reset_timeout":    cb.config.ResetTimeout,
		"half_open_max_reqs": cb.config.HalfOpenMaxReqs,
	}
}

// IsOpen 检查熔断器是否处于开启状态
func (cb *CircuitBreaker) IsOpen() bool {goCover_649b36dcf066__52[0] = 1 ; goCover_649b36dcf066__52[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__52[2] = 52 ; goCover_649b36dcf066__52[3] = 1;
	cb.mutex.RLock()
	defer cb.mutex.RUnlock()
	return cb.state == StateOpenCB
}

// IsClosed 检查熔断器是否处于关闭状态
func (cb *CircuitBreaker) IsClosed() bool {goCover_649b36dcf066__53[0] = 1 ; goCover_649b36dcf066__53[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__53[2] = 53 ; goCover_649b36dcf066__53[3] = 1;
	cb.mutex.RLock()
	defer cb.mutex.RUnlock()
	return cb.state == StateClosedCB
}

// IsHalfOpen 检查熔断器是否处于半开状态
func (cb *CircuitBreaker) IsHalfOpen() bool {goCover_649b36dcf066__54[0] = 1 ; goCover_649b36dcf066__54[1] = goCover_649b36dcf066_P ; goCover_649b36dcf066__54[2] = 54 ; goCover_649b36dcf066__54[3] = 1;
	cb.mutex.RLock()
	defer cb.mutex.RUnlock()
	return cb.state == StateHalfOpenCB
}